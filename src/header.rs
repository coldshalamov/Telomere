//! Bit packed batch header used throughout the Telomere format.
//!
//! A header is encoded as an EVQL seed index followed by a dynamic arity
//! toggle.  The July 2025 protocol uses an "arity‑2 as terminal" scheme
//! where literal spans share the same toggle as the final block marker.
//! All fields are packed bit‑wise with no padding so typical headers fit
//! within a few bytes.
//!
//! Bit layout (from MSB to LSB):
//!
//! ```text
//! EVQL(seed index) | dynamic arity bits
//! ```
//!
//! The seed index determines which generated block to apply.  The arity
//! selects how many blocks are reconstructed or whether literal bytes are
//! copied.  When present the decoder compares the generated bytes against
//! the truncated hash stored in the surrounding batch header.

use thiserror::Error;
use crate::TelomereError;

/**
Telomere headers use dynamic toggles (dToggles) for the arity field and
exponential VQL (eVQL) for the seed index.

Bits (first–third window) | Meaning                  | Action
0                           | arity 1                  | use seed index, 1 block
1 0                         | arity 2 (terminal)       | NO seed index, literal span
1 1 000                     | arity 3                  | use seed index, 3 blocks
1 1 001                     | arity 4                  | use seed index, 4 blocks
1 1 010                     | arity 5                  | use seed index, 5 blocks
1 1 011                     | arity 6                  | use seed index, 6 blocks
1 1 100                     | arity 7                  | use seed index, 7 blocks
1 1 101                     | arity 8                  | use seed index, 8 blocks
1 1 110                     | arity 9                  | use seed index, 9 blocks
1 1 111                     | arity 10                 | use seed index, 10 blocks
*/

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Header {
    /// Standard compressed span of `arity` blocks using the provided seed index.
    Standard { seed_index: usize, arity: usize },
    /// Skip literal bytes. In the July 2025 protocol this uses the same arity
    /// toggle as the final block marker. `LiteralLast` encodes identically but
    /// is preserved as a variant for convenience.
    Literal,
    /// Literal span that also terminates decoding. Encoded the same as
    /// [`Literal`].
    LiteralLast,
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum HeaderError {
    #[error("unexpected end of input")]
    UnexpectedEof,
    #[error("invalid arity code")]
    InvalidArity,
}

/// Encode a Telomere header and return packed bytes.
pub fn encode_header(h: &Header) -> Result<Vec<u8>, TelomereError> {
    let mut bits = Vec::new();
    match *h {
        Header::Standard { seed_index, arity } => {
            let arity_bits = encode_arity_bits(arity)
                .ok_or_else(|| TelomereError::Config("arity out of range".into()))?;
            bits.extend(arity_bits);
            bits.extend(encode_evql_bits(seed_index));
        }
        Header::Literal => bits.extend([true, false]),
        Header::LiteralLast => bits.extend([true, true, true, true, true, true]),
    }
    Ok(pack_bits(&bits))
}

/// Decode a Telomere header from a bitstream. Returns the header and number of
/// bits consumed.
pub fn decode_header(data: &[u8]) -> Result<(Header, usize), HeaderError> {
    let mut pos = 0usize;
    let variant = decode_arity_stream(data, &mut pos)?;
    let header = match variant {
        ArityVariant::Standard(arity) => {
            let seed = decode_evql(data, &mut pos)?;
            Header::Standard { seed_index: seed, arity }
        }
        ArityVariant::Literal => Header::Literal,
        ArityVariant::LiteralLast => Header::LiteralLast,
    };
    Ok((header, pos))
}

// --- internal encoding helpers ---

#[derive(Debug)]
enum ArityVariant {
    Standard(usize),
    Literal,
    LiteralLast,
}

/// Encode arity bits according to the July 2025 toggle scheme.
fn encode_arity_bits(arity: usize) -> Option<Vec<bool>> {
    match arity {
        1 => Some(vec![false]),
        2 => Some(vec![true, false]),
        3..=9 => {
            let value = arity - 3;
            let mut bits = vec![true, true];
            for i in (0..3).rev() {
                bits.push(((value >> i) & 1) != 0);
            }
            Some(bits)
        }
        10 => Some(vec![true, true, true, true, true, false]),
        _ => None,
    }
}

fn decode_arity_stream(data: &[u8], pos: &mut usize) -> Result<ArityVariant, HeaderError> {
    let first = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
    *pos += 1;
    if !first {
        return Ok(ArityVariant::Standard(1));
    }
    let b1 = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
    *pos += 1;
    if !b1 {
        return Ok(ArityVariant::Literal);
    }
    let mut value = 0usize;
    for _ in 0..3 {
        let bit = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
        *pos += 1;
        value = (value << 1) | (bit as usize);
    }
    if value == 7 {
        let bit = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
        *pos += 1;
        if bit {
            return Ok(ArityVariant::LiteralLast);
        } else {
            return Ok(ArityVariant::Standard(10));
        }
    }
    let arity = value + 3;
    if (3..=9).contains(&arity) {
        Ok(ArityVariant::Standard(arity))
    } else {
        Err(HeaderError::InvalidArity)
    }
}

fn encode_evql_bits(mut value: usize) -> Vec<bool> {
    let mut width = 1usize;
    let mut n = 0usize;
    while value >= (1usize << width) {
        width <<= 1;
        n += 1;
    }
    let mut bits = vec![true; n];
    bits.push(false);
    for i in (0..width).rev() {
        bits.push(((value >> i) & 1) != 0);
    }
    bits
}

fn decode_evql(input: &[u8], pos: &mut usize) -> Result<usize, HeaderError> {
    let mut n = 0usize;
    loop {
        match get_bit(input, *pos) {
            Some(true) => {
                n += 1;
                *pos += 1;
            }
            Some(false) => {
                *pos += 1;
                break;
            }
            None => return Err(HeaderError::UnexpectedEof),
        }
    }
    let width = 1usize << n;
    let mut value = 0usize;
    for _ in 0..width {
        match get_bit(input, *pos) {
            Some(bit) => {
                value = (value << 1) | (bit as usize);
                *pos += 1;
            }
            None => return Err(HeaderError::UnexpectedEof),
        }
    }
    Ok(value)
}

fn get_bit(data: &[u8], pos: usize) -> Option<bool> {
    if pos / 8 >= data.len() {
        None
    } else {
        Some(((data[pos / 8] >> (7 - (pos % 8))) & 1) != 0)
    }
}

fn pack_bits(bits: &[bool]) -> Vec<u8> {
    let mut out = Vec::new();
    let mut byte = 0u8;
    let mut used = 0u8;
    for &b in bits {
        byte = (byte << 1) | b as u8;
        used += 1;
        if used == 8 {
            out.push(byte);
            byte = 0;
            used = 0;
        }
    }
    if used > 0 {
        byte <<= 8 - used;
        out.push(byte);
    }
    if out.is_empty() {
        out.push(0);
    }
    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn all_headers_roundtrip() {
        let cases = vec![
            Header::Standard { seed_index: 0, arity: 1 },
            Header::Standard { seed_index: 1, arity: 3 },
            Header::Standard { seed_index: 2, arity: 4 },
            Header::Standard { seed_index: 3, arity: 10 },
            Header::Literal,
            Header::LiteralLast,
        ];

        for h in cases {
            let enc = encode_header(&h).unwrap();
            let (decoded, bits) = decode_header(&enc).unwrap();
            assert_eq!(decoded, h);
            assert!(bits <= enc.len() * 8);
        }
    }
}
