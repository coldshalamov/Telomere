//! Bit packed batch header used throughout the Telomere format.
//!
//! A header is encoded as an EVQL seed index followed by a toggle based
//! arity code.  The result typically fits within three bytes for small
//! values.  Decoders perform basic sanity checks including verifying a
//! truncated SHA‑256 of the reconstructed output when available.
//!
//! Bit layout (from MSB to LSB):
//!
//! ```text
//! EVQL(seed index) | dynamic arity bits
//! ```
//!
//! The seed index determines which generated block to apply.  The arity
//! selects how many blocks are reconstructed or whether literal bytes are
//! copied.  When present the decoder compares the generated bytes against
//! the truncated hash stored in the surrounding batch header.

use thiserror::Error;

/**
Telomere header encoding uses dynamic toggles (dToggles) for the arity field and
exponential VQL (eVQL) for the seed index. The table below enumerates every
valid header pattern. Marker headers never include a seed index.

Bits (first–third window) | Meaning                                 | Action
0                           | arity 1                                 | use seed index, 1 block
1 00                        | arity 2                                 | use seed index, 2 blocks
1 01                        | arity 3                                 | use seed index, 3 blocks
1 10                        | arity 4                                 | use seed index, 4 blocks
1 11 000                    | arity 5                                 | use seed index, 5 blocks
1 11 001                    | arity 6                                 | use seed index, 6 blocks
1 11 010                    | arity 7                                 | use seed index, 7 blocks
1 11 011                    | penultimate, arity 1 (marker)           | use seed index, 1 block
1 11 100                    | penultimate, arity 2 (marker)           | use seed index, 2 blocks
1 11 101                    | penultimate, arity 3 (marker)           | use seed index, 3 blocks
1 11 110                    | literal block (marker)                  | NO seed index, skip 1 block
1 11 111                    | literal last block (marker)             | NO seed index, skip 1 block and END
*/

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Header {
    /// Standard compressed span of N blocks using the provided seed index.
    Standard { seed_index: usize, arity: usize },
    /// Marks the penultimate compressed span. The following header must be a
    /// literal or literal last block. See table above.
    Penultimate { seed_index: usize, arity: usize },
    /// Skip the next block literally.
    Literal,
    /// Skip the next block literally and finish decoding.
    LiteralLast,
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum HeaderError {
    #[error("unexpected end of input")]
    UnexpectedEof,
    #[error("invalid arity code")]
    InvalidArity,
}

/// Encode a Telomere header and return packed bytes.
pub fn encode_header(h: &Header) -> Vec<u8> {
    let mut bits = Vec::new();
    match *h {
        Header::Standard { seed_index, arity } => {
            bits.extend(encode_arity_bits(arity, false).expect("arity out of range"));
            bits.extend(encode_evql_bits(seed_index));
        }
        Header::Penultimate { seed_index, arity } => {
            bits.extend(encode_arity_bits(arity, true).expect("arity out of range"));
            bits.extend(encode_evql_bits(seed_index));
        }
        Header::Literal => bits.extend([true, true, true, true, true, false]),
        Header::LiteralLast => bits.extend([true, true, true, true, true, true]),
    }
    pack_bits(&bits)
}

/// Decode a Telomere header from a bitstream. Returns the header and number of
/// bits consumed.
pub fn decode_header(data: &[u8]) -> Result<(Header, usize), HeaderError> {
    let mut pos = 0usize;
    let variant = decode_arity_stream(data, &mut pos)?;
    let header = match variant {
        ArityVariant::Standard(arity) => {
            let seed = decode_evql(data, &mut pos)?;
            Header::Standard { seed_index: seed, arity }
        }
        ArityVariant::Penultimate(arity) => {
            let seed = decode_evql(data, &mut pos)?;
            Header::Penultimate { seed_index: seed, arity }
        }
        ArityVariant::Literal => Header::Literal,
        ArityVariant::LiteralLast => Header::LiteralLast,
    };
    Ok((header, pos))
}

// --- internal encoding helpers ---

#[derive(Debug)]
enum ArityVariant {
    Standard(usize),
    Penultimate(usize),
    Literal,
    LiteralLast,
}

/// Encode arity bits according to the table. `penultimate` toggles the marker
/// window.
fn encode_arity_bits(arity: usize, penultimate: bool) -> Option<Vec<bool>> {
    let bits = match (penultimate, arity) {
        (false, 1) => vec![false],
        (false, 2) => vec![true, false, false],
        (false, 3) => vec![true, false, true],
        (false, 4) => vec![true, true, false],
        (false, 5) => vec![true, true, true, false, false, false],
        (false, 6) => vec![true, true, true, false, false, true],
        (false, 7) => vec![true, true, true, false, true, false],
        (true, 1) => vec![true, true, true, false, true, true],
        (true, 2) => vec![true, true, true, true, false, false],
        (true, 3) => vec![true, true, true, true, false, true],
        _ => return None,
    };
    Some(bits)
}

fn decode_arity_stream(data: &[u8], pos: &mut usize) -> Result<ArityVariant, HeaderError> {
    let first = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
    *pos += 1;
    if !first {
        return Ok(ArityVariant::Standard(1));
    }
    let b1 = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
    *pos += 1;
    let b2 = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
    *pos += 1;
    match (b1, b2) {
        (false, false) => Ok(ArityVariant::Standard(2)),
        (false, true) => Ok(ArityVariant::Standard(3)),
        (true, false) => Ok(ArityVariant::Standard(4)),
        (true, true) => {
            let c1 = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
            *pos += 1;
            let c2 = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
            *pos += 1;
            let c3 = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
            *pos += 1;
            match (c1, c2, c3) {
                (false, false, false) => Ok(ArityVariant::Standard(5)),
                (false, false, true) => Ok(ArityVariant::Standard(6)),
                (false, true, false) => Ok(ArityVariant::Standard(7)),
                (false, true, true) => Ok(ArityVariant::Penultimate(1)),
                (true, false, false) => Ok(ArityVariant::Penultimate(2)),
                (true, false, true) => Ok(ArityVariant::Penultimate(3)),
                (true, true, false) => Ok(ArityVariant::Literal),
                (true, true, true) => Ok(ArityVariant::LiteralLast),
            }
        }
    }
}

fn encode_evql_bits(mut value: usize) -> Vec<bool> {
    let mut width = 1usize;
    let mut n = 0usize;
    while value >= (1usize << width) {
        width <<= 1;
        n += 1;
    }
    let mut bits = vec![true; n];
    bits.push(false);
    for i in (0..width).rev() {
        bits.push(((value >> i) & 1) != 0);
    }
    bits
}

fn decode_evql(input: &[u8], pos: &mut usize) -> Result<usize, HeaderError> {
    let mut n = 0usize;
    loop {
        match get_bit(input, *pos) {
            Some(true) => {
                n += 1;
                *pos += 1;
            }
            Some(false) => {
                *pos += 1;
                break;
            }
            None => return Err(HeaderError::UnexpectedEof),
        }
    }
    let width = 1usize << n;
    let mut value = 0usize;
    for _ in 0..width {
        match get_bit(input, *pos) {
            Some(bit) => {
                value = (value << 1) | (bit as usize);
                *pos += 1;
            }
            None => return Err(HeaderError::UnexpectedEof),
        }
    }
    Ok(value)
}

fn get_bit(data: &[u8], pos: usize) -> Option<bool> {
    if pos / 8 >= data.len() {
        None
    } else {
        Some(((data[pos / 8] >> (7 - (pos % 8))) & 1) != 0)
    }
}

fn pack_bits(bits: &[bool]) -> Vec<u8> {
    let mut out = Vec::new();
    let mut byte = 0u8;
    let mut used = 0u8;
    for &b in bits {
        byte = (byte << 1) | b as u8;
        used += 1;
        if used == 8 {
            out.push(byte);
            byte = 0;
            used = 0;
        }
    }
    if used > 0 {
        byte <<= 8 - used;
        out.push(byte);
    }
    if out.is_empty() {
        out.push(0);
    }
    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn all_headers_roundtrip() {
        let cases = vec![
            Header::Standard { seed_index: 0, arity: 1 },
            Header::Standard { seed_index: 3, arity: 2 },
            Header::Standard { seed_index: 7, arity: 3 },
            Header::Standard { seed_index: 1, arity: 4 },
            Header::Standard { seed_index: 2, arity: 5 },
            Header::Standard { seed_index: 3, arity: 6 },
            Header::Standard { seed_index: 4, arity: 7 },
            Header::Penultimate { seed_index: 5, arity: 1 },
            Header::Penultimate { seed_index: 6, arity: 2 },
            Header::Penultimate { seed_index: 7, arity: 3 },
            Header::Literal,
            Header::LiteralLast,
        ];

        for h in cases {
            let enc = encode_header(&h);
            let (decoded, bits) = decode_header(&enc).unwrap();
            assert_eq!(decoded, h);
            assert!(bits <= enc.len() * 8);
        }
    }
}
