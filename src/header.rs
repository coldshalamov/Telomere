//! Bit packed batch header used throughout the Telomere format.
//!
//! A header is encoded as an EVQL seed index followed by a dynamic arity
//! toggle.  The July 2025 protocol uses an "arity‑2 as terminal" scheme
//! where literal spans share the same toggle as the final block marker.
//! All fields are packed bit‑wise with no padding so typical headers fit
//! within a few bytes.
//!
//! Bit layout (from MSB to LSB):
//!
//! ```text
//! EVQL(seed index) | dynamic arity bits
//! ```
//!
//! The seed index determines which generated block to apply.  The arity
//! selects how many blocks are reconstructed or whether literal bytes are
//! copied.  When present the decoder compares the generated bytes against
//! the truncated hash stored in the surrounding batch header.

use thiserror::Error;
use std::collections::HashMap;
use std::io::{Read, Cursor};

/**
Telomere headers use dynamic toggles (dToggles) for the arity field and
exponential VQL (eVQL) for the seed index.

Bits (first–third window) | Meaning                  | Action
0                           | arity 1                  | use seed index, 1 block
1 0                         | arity 2 (terminal)       | NO seed index, literal span
1 1 000                     | arity 3                  | use seed index, 3 blocks
1 1 001                     | arity 4                  | use seed index, 4 blocks
1 1 010                     | arity 5                  | use seed index, 5 blocks
1 1 011                     | arity 6                  | use seed index, 6 blocks
1 1 100                     | arity 7                  | use seed index, 7 blocks
1 1 101                     | arity 8                  | use seed index, 8 blocks
1 1 110                     | arity 9                  | use seed index, 9 blocks
1 1 111                     | arity 10                 | use seed index, 10 blocks
*/

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Header {
    /// Standard compressed span of `arity` blocks using the provided seed index.
    Standard { seed_index: usize, arity: usize },
    /// Skip literal bytes. In the July 2025 protocol this uses the same arity
    /// toggle as the final block marker. `LiteralLast` encodes identically but
    /// is preserved as a variant for convenience.
    Literal,
    /// Literal span that also terminates decoding. Encoded the same as
    /// [`Literal`].
    LiteralLast,
}

/// Configuration for recursive decoding.
#[derive(Debug, Clone, Default)]
pub struct Config {
    pub block_size: usize,
    /// Mapping from seed indices to generated bitstreams used during decoding.
    pub seed_expansions: HashMap<usize, Vec<u8>>,
}

/// Errors that can occur during recursive decoding.
#[derive(Debug, Error)]
pub enum TelomereError {
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
    #[error("unexpected end of input")]
    UnexpectedEof,
    #[error("invalid arity code")]
    InvalidArity,
    #[error("missing seed expansion")]
    MissingSeed,
}

/// Simple big-endian bit reader over any `Read` implementation.
pub struct BitReader<R: Read> {
    inner: R,
    buf: u8,
    remaining: u8,
}

impl<R: Read> BitReader<R> {
    pub fn new(inner: R) -> Self {
        Self { inner, buf: 0, remaining: 0 }
    }

    fn read_bit(&mut self) -> Result<bool, TelomereError> {
        if self.remaining == 0 {
            let mut byte = [0u8; 1];
            let n = self.inner.read(&mut byte)?;
            if n == 0 {
                return Err(TelomereError::UnexpectedEof);
            }
            self.buf = byte[0];
            self.remaining = 8;
        }
        self.remaining -= 1;
        Ok(((self.buf >> self.remaining) & 1) != 0)
    }

    fn read_bits(&mut self, count: usize) -> Result<u64, TelomereError> {
        let mut val = 0u64;
        for _ in 0..count {
            val = (val << 1) | self.read_bit()? as u64;
        }
        Ok(val)
    }

    pub fn read_bytes(&mut self, count: usize) -> Result<Vec<u8>, TelomereError> {
        let mut out = Vec::with_capacity(count);
        for _ in 0..count {
            out.push(self.read_bits(8)? as u8);
        }
        Ok(out)
    }
}

impl<'a> BitReader<Cursor<&'a [u8]>> {
    pub fn from_slice(data: &'a [u8]) -> Self {
        BitReader::new(Cursor::new(data))
    }
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum HeaderError {
    #[error("unexpected end of input")]
    UnexpectedEof,
    #[error("invalid arity code")]
    InvalidArity,
}

/// Encode a Telomere header and return packed bytes.
pub fn encode_header(h: &Header) -> Vec<u8> {
    let mut bits = Vec::new();
    match *h {
        Header::Standard { seed_index, arity } => {
            bits.extend(encode_arity_bits(arity).expect("arity out of range"));
            bits.extend(encode_evql_bits(seed_index));
        }
        Header::Literal => bits.extend([true, false]),
        Header::LiteralLast => bits.extend([true, true, true, true, true, true]),
    }
    pack_bits(&bits)
}

/// Decode a Telomere header from a bitstream. Returns the header and number of
/// bits consumed.
pub fn decode_header(data: &[u8]) -> Result<(Header, usize), HeaderError> {
    let mut pos = 0usize;
    let variant = decode_arity_stream(data, &mut pos)?;
    let header = match variant {
        ArityVariant::Standard(arity) => {
            let seed = decode_evql(data, &mut pos)?;
            Header::Standard { seed_index: seed, arity }
        }
        ArityVariant::Literal => Header::Literal,
        ArityVariant::LiteralLast => Header::LiteralLast,
    };
    Ok((header, pos))
}

// --- internal encoding helpers ---

#[derive(Debug)]
enum ArityVariant {
    Standard(usize),
    Literal,
    LiteralLast,
}

/// Encode arity bits according to the July 2025 toggle scheme.
fn encode_arity_bits(arity: usize) -> Option<Vec<bool>> {
    match arity {
        1 => Some(vec![false]),
        2 => Some(vec![true, false]),
        3..=9 => {
            let value = arity - 3;
            let mut bits = vec![true, true];
            for i in (0..3).rev() {
                bits.push(((value >> i) & 1) != 0);
            }
            Some(bits)
        }
        10 => Some(vec![true, true, true, true, true, false]),
        _ => None,
    }
}

fn decode_arity_stream(data: &[u8], pos: &mut usize) -> Result<ArityVariant, HeaderError> {
    let first = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
    *pos += 1;
    if !first {
        return Ok(ArityVariant::Standard(1));
    }
    let b1 = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
    *pos += 1;
    if !b1 {
        return Ok(ArityVariant::Literal);
    }
    let mut value = 0usize;
    for _ in 0..3 {
        let bit = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
        *pos += 1;
        value = (value << 1) | (bit as usize);
    }
    if value == 7 {
        let bit = get_bit(data, *pos).ok_or(HeaderError::UnexpectedEof)?;
        *pos += 1;
        if bit {
            return Ok(ArityVariant::LiteralLast);
        } else {
            return Ok(ArityVariant::Standard(10));
        }
    }
    let arity = value + 3;
    if (3..=9).contains(&arity) {
        Ok(ArityVariant::Standard(arity))
    } else {
        Err(HeaderError::InvalidArity)
    }
}

fn encode_evql_bits(mut value: usize) -> Vec<bool> {
    let mut width = 1usize;
    let mut n = 0usize;
    while value >= (1usize << width) {
        width <<= 1;
        n += 1;
    }
    let mut bits = vec![true; n];
    bits.push(false);
    for i in (0..width).rev() {
        bits.push(((value >> i) & 1) != 0);
    }
    bits
}

fn decode_evql(input: &[u8], pos: &mut usize) -> Result<usize, HeaderError> {
    let mut n = 0usize;
    loop {
        match get_bit(input, *pos) {
            Some(true) => {
                n += 1;
                *pos += 1;
            }
            Some(false) => {
                *pos += 1;
                break;
            }
            None => return Err(HeaderError::UnexpectedEof),
        }
    }
    let width = 1usize << n;
    let mut value = 0usize;
    for _ in 0..width {
        match get_bit(input, *pos) {
            Some(bit) => {
                value = (value << 1) | (bit as usize);
                *pos += 1;
            }
            None => return Err(HeaderError::UnexpectedEof),
        }
    }
    Ok(value)
}

fn get_bit(data: &[u8], pos: usize) -> Option<bool> {
    if pos / 8 >= data.len() {
        None
    } else {
        Some(((data[pos / 8] >> (7 - (pos % 8))) & 1) != 0)
    }
}

fn pack_bits(bits: &[bool]) -> Vec<u8> {
    let mut out = Vec::new();
    let mut byte = 0u8;
    let mut used = 0u8;
    for &b in bits {
        byte = (byte << 1) | b as u8;
        used += 1;
        if used == 8 {
            out.push(byte);
            byte = 0;
            used = 0;
        }
    }
    if used > 0 {
        byte <<= 8 - used;
        out.push(byte);
    }
    if out.is_empty() {
        out.push(0);
    }
    out
}

// --- recursive decoding helpers ---

fn read_arity<R: Read>(reader: &mut BitReader<R>) -> Result<usize, TelomereError> {
    let first = reader.read_bit()?;
    if !first {
        return Ok(1);
    }
    let b1 = reader.read_bit()?;
    if !b1 {
        return Ok(2);
    }
    let mut value = 0usize;
    for _ in 0..3 {
        value = (value << 1) | reader.read_bit()? as usize;
    }
    if value == 7 {
        let bit = reader.read_bit()?;
        if bit {
            // treat literal-last as literal
            return Ok(2);
        } else {
            return Ok(10);
        }
    }
    let arity = value + 3;
    if (3..=9).contains(&arity) {
        Ok(arity)
    } else {
        Err(TelomereError::InvalidArity)
    }
}

fn read_evql<R: Read>(reader: &mut BitReader<R>) -> Result<usize, TelomereError> {
    let mut n = 0usize;
    while reader.read_bit()? {
        n += 1;
    }
    let width = 1usize << n;
    let mut value = 0usize;
    for _ in 0..width {
        value = (value << 1) | reader.read_bit()? as usize;
    }
    Ok(value)
}

fn generate_bits(config: &Config, seed_idx: usize) -> Result<Vec<u8>, TelomereError> {
    if let Some(bits) = config.seed_expansions.get(&seed_idx) {
        Ok(bits.clone())
    } else {
        Err(TelomereError::MissingSeed)
    }
}

fn decode_span<R: Read>(reader: &mut BitReader<R>, config: &Config) -> Result<Vec<u8>, TelomereError> {
    let arity = read_arity(reader)?;
    if arity == 2 {
        return Ok(reader.read_bytes(config.block_size)?);
    }
    let seed_idx = read_evql(reader)?;
    let child_bits = generate_bits(config, seed_idx)?;
    let mut child_reader = BitReader::from_slice(&child_bits);
    let mut out = Vec::new();
    for _ in 0..arity {
        out.extend(decode_span(&mut child_reader, config)?);
    }
    Ok(out)
}

/// Decode a stream of blocks described by nested headers.
pub fn decode<R: Read>(reader: &mut BitReader<R>, config: &Config) -> Result<Vec<u8>, TelomereError> {
    let block_count = read_evql(reader)?;
    let mut result = Vec::new();
    for _ in 0..block_count {
        result.extend(decode_span(reader, config)?);
    }
    Ok(result)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn all_headers_roundtrip() {
        let cases = vec![
            Header::Standard { seed_index: 0, arity: 1 },
            Header::Standard { seed_index: 1, arity: 3 },
            Header::Standard { seed_index: 2, arity: 4 },
            Header::Standard { seed_index: 3, arity: 10 },
            Header::Literal,
            Header::LiteralLast,
        ];

        for h in cases {
            let enc = encode_header(&h);
            let (decoded, bits) = decode_header(&enc).unwrap();
            assert_eq!(decoded, h);
            assert!(bits <= enc.len() * 8);
        }
    }
}
